local ResourcesManager ={};

ResourcesManager.__index =ResourcesManager;


--------------------------资源表--------------------------
--所有不销毁的obj列表
ResourcesManager.dontDestroyObjAry = {};

--已加载资源的实例化列表，实例化后的obj都存储在这里
--asset--{path, userMap={id--obj}}
ResourcesManager.assetListenerMap = {};

--缓存了所有的AB本身
--path = {assetBundle, refCount}
ResourcesManager.assetBundleCacheMap = {}

--初始化解析主manifest后获得，记录所有AB之间的依赖
ResourcesManager.abAllDependenciesMap = {}

--路径缓存表
ResourcesManager.pathCache ={};

--产生一个实例
function ResourcesManager:init()
    local instance = {};
    setmetatable(instance,ResourcesManager);
    return instance
end


---------------------------外部接口-------------------------
--同步实例化
--请求路径，类型，位置，父物体
function ResourcesManager:syncInstantiate(path,type,parent,position,rotation)
    --提供借口
    local objAsset ;
    --加载resources资源
    if type == 1  then
        objAsset=self:LoadResources(path);

        --加载assetbundle资源
    elseif type >= 20 then
        objAsset =self:LoadAssetBundle(type,path);
    else
        print("没有这种加载类型");
    end


    if objAsset then
        return self:instantiate(path, parent, position,rotation);
    else
        print('error to load');
    end

end

--删除对内存资源的引用
--提供给外部调用
function ResourcesManager:clear()

    for i,v in ipairs(self.pathCache) do
        print(self.assetBundleCacheMap[v].assetBundle);
        self.assetBundleCacheMap[v].assetBundle:Unload(false);
    end
    for i,v in ipairs(self) do
        self.remove(self,i);
        --self.assetListenerMap.Unloado();
    end
    for j,v in ipairs(self) do
        print(j..v);
    end
    print("resources drop");
end

--删除单个物体
function ResourcesManager:dropResoureces(obj)

    CS.UnityEngine.GameObject.Destroy(obj);
    --弱卸载，回收无用Assets
    CS.UnityEngine.Resources.UnloadUnusedAssets();
end


----------------------------内部接口---------------------------------------
--资源实例化
function ResourcesManager:instantiate(path, parent, position, rotation)
    local gameObj
    if parent then
        --self.object:GetComponent("Transform"):SetParent(parent:GetComponent("Transform"));
        if position then
            gameObj = CS.UnityEngine.Object.Instantiate(self.assetListenerMap[path], position, rotation or CS.UnityEngine.Quaternion.identity);
        else
            gameObj = CS.UnityEngine.Object.Instantiate(self.assetListenerMap[path], parent.Transform, false);
        end
        gameObj:GetComponent("Transform"):SetParent(parent:GetComponent("Transform"));
    else
        gameObj = CS.UnityEngine.Object.Instantiate(self.assetListenerMap[path], position or CS.UnityEngine.Vector3.zero, rotation or CS.UnityEngine.Quaternion.identity);
    end
    --GameObject =CS.UnityEngine.Object.Instantiate(self.assetListenerMap[original]);
    --self.object.transform.localPosition=location;
    return gameObj
end

--根据assetbundle路径查找ab资源信息(不含后缀）
function ResourcesManager:findName(path)
    local objpath = nil;
    --print("正则表达式:");
    objpath =string.match(path,"/[%w]+%.");
    --print(string.sub(objpath,2,#objpath-1));
    return string.sub(objpath,2,#objpath-1)
end

--根据assetbundle路径查找ab资源信息（含后缀）
function ResourcesManager:findAllName(path)
    local allName =nil;
    --print("正则表达式");
    allName =string.match(path,"/[%w]+%.[%w]+");
    --print(allName);
    return string.sub(allName,2);
end

--加载resources资源
function ResourcesManager:LoadResources(path)
    self.assetListenerMap[path] = CS.UnityEngine.Resources.Load(path);
    if self.assetListenerMap[path] then
        --print(self.assetListenerMap[path]);
        return 1
    else
        return nil
    end
end

--加载assetbundle资源
function ResourcesManager:LoadAssetBundle(type,path)
    --加载manifest查找依赖
    --self:LoadManifest('Assets/AssetBundles',self:findAllName(path));
    --local load
    if type ==21 then
        return self:LoadLocalAssetBundle(path);
    --memoery load
    elseif type ==22 then
        return self:LoadMemoryAssetBundle();
    --request load
    elseif type ==23 then
        return self:LoadRequestAssetBundle();
    end

end

--加载本地assetbundle资源
--已测试
function ResourcesManager:LoadLocalAssetBundle(path)
    --加载
    local temp =CS.UnityEngine.AssetBundle.LoadFromFile(path);
    --缓存ab本身
    self.assetBundleCacheMap[path] ={assetBundle = temp,refCount =1};
    --缓存ab索引
    table.insert(self.pathCache,path);
    --寻找路径中的ab包名
    local temppath = self:findName(path);
    self.assetListenerMap[path]=temp:LoadAsset(temppath);
    if self.assetListenerMap[path] then
        return 1
    else
        return nil
    end
end

--加载内存assetbundle资源
--未测试
function ResourcesManager:LoadMemoryAssetBundle(path)
    --加载assetbundle
    local temp =CS.UnityEngine.AssetBundle.LoadFromMemory(CS.UnityEngine.Windows.File.ReadAllBytes(path));
    local temppath = self:findName(self.path);
    --加载asset
    self.assetListenerMap[path]=temp:LoadAsset(temppath);
    if self.assetListenerMap[path] then
        return 1
    else
        return nil
    end
end

--加载asset资源包所依赖的资源包的名字
function ResourcesManager:LoadManifest(abPath,abName)
    local manifestAb = CS.UnityEngine.AssetBundle.LoadFromFile(abPath);
    local manifest =manifestAb:LoadAsset("AssetBundleManifest");
    self.abAllDependenciesMap[abPath] = manifest:GetAllDependencies(abName);
    for i ,v in self.abAllDependenciesMap[abPath] do
        CS.UnityEngine.AssetBundle.LoadFromFile("Asset/AssetBundles/"..v);
    end
end

--加载服务器assetbundle资源
--未实现
function ResourcesManager:LoadRequestAssetBundle()
    local request = {};
    local temp =CS.UnityEngine.AssetBundle.LoadFromMemory(File.ReadAllBytes(self.path));
    local temppath = self:findName(self.path);
    self.object=CS.UnityEngine.Object.Instantiate(temp:LoadAsset(temppath));
end

ResourcesManager:init();

return ResourcesManager