
local ResourcesManager ={};

ResourcesManager.__index =ResourcesManager;


--------------------------资源表--------------------------


--产生一个实例
--改成"单例模式"
function ResourcesManager:init()
    --local instance = {};
    --setmetatable(instance,ResourcesManager);
    --return instance

    --加载好的gameobj
    --{path = gameobj}
    self.objMap ={};

    --缓存了所有的AB本身，path = {assetBundle, refCount}
    self.assetBundleCacheMap = {};

    --初始化解析主manifest后获得，记录所有AB之间的依赖
    self.abAllDependenciesMap = {};

    --资源池
    --{path = name,gameobj =gameobj}
    self.objPool ={};
end


---------------------------外部接口-------------------------
--同步实例化
--请求路径，类型，父物体，位置，角度
function ResourcesManager:syncInstantiate(path,type,parent,position,rotation)
    --path是否正确且资源是否能被加载
    local objBool;
    --加载resources资源
    if type == 1 then
        objBool = self:LoadResources(path);
        --加载assetbundle资源
    elseif type >= 2 then
        objBool =self:LoadAssetBundle(type,path);
    else
        print("error type ");
    end

    --返回实例化的对象
    if objBool then
        return self:instantiate(path,parent,position,rotation);
    else
        print("load path error or resources wrong");
        return nil
    end

end

--只使用路径和类型加载
--下次想要使用资源的时候可以直接加载
function ResourcesManager:LoadPath(path,type)
    --加载resources资源
    if type == 1 then
        self:LoadResources(path);
        --加载assetbundle资源
    elseif type >= 2 then
        self:LoadAssetBundle(type,path);
    else
        print("error type ");
    end
    return self.objMap[path];
end

function ResourcesManager:instantiatePath(path,type,parent,position,rotation)
    if self.objMap[path] == nil then
        return self:syncInstantiate(path,type,parent,position,rotation);
    else
        return self:syncInstantiate(path,type,parent,position,rotation);
    end
end

--删除对内存资源的引用
--删除资源
--提供给外部调用
function ResourcesManager:clear()
    --删除缓存
    print("ResourcesManager is clearing ");
    for path, abCache in pairs(self.assetBundleCacheMap) do
        print("unload asset bundle, path is ", path);
        abCache.assetBundle:Unload(false);
    end
    self.assetBundleCacheMap = {};
    --直接不持有，即可在UnloadUnusedAssets中回收相关资源

    print("destroy objmap");
    for i, obj in pairs(self.objMap) do
        print(obj);
        self.objMap[i] =nil;
    end
    print("destroy objpool");
    for i,obj in pairs(self.objPool) do
        print(obj);
        CS.UnityEngine.Object.Destroy(obj);
    end
end

--删除单个物体
function ResourcesManager:dropResoureces(obj)
    --清除对象
    CS.UnityEngine.Object.Destroy(obj);
end


----------------------------内部接口----------------------------------

--不销毁资源接口
--暂时无不需要销毁的资源，唯一不销毁资源只有挂靠luabehaviour的物体，直接在luabehaviour声明
function ResourcesManager:DontDestroyOnLoad(obj)
    CS.UnityEngine.GameObject.DontDestroyOnLoad(obj);
    table.insert(self.dontDestroyObjAry, obj);
end



--根据assetbundle路径查找ab资源信息(不含后缀）
--例如 human
function ResourcesManager:findName(path)
    local objPath = nil;
    objPath =string.match(path,"/[%w]+%.");
    return string.sub(objPath,2,#objPath-1)
end

--根据assetbundle路径查找ab资源信息（含后缀）
--例如 human.pre
function ResourcesManager:findAllName(path)
    local fullName =nil;
    fullName =string.match(path,"/[%w]+%.[%w]+");
    return string.sub(fullName,2);
end

--加载asset资源包所依赖的资源包的名字
--manifest 文件在assetbundle下无法被读取
function ResourcesManager:LoadManifest()
    --print("Assets/AssetBundles");
    print(CS.UnityEngine.Application.dataPath);
    local manifestAb = CS.UnityEngine.AssetBundle.LoadFromFile(CS.UnityEngine.Application.streamingAssetsPath.."/StreamingAssets");
    print(manifestAb);
    local manifest =manifestAb:LoadAsset("AssetBundleManifest");
    print(manifest);
    self.abAllDependenciesMap= manifest:GetAllDependencies("human");
    for i ,v in pairs(self.abAllDependenciesMap) do
        CS.UnityEngine.AssetBundle.LoadFromFile(CS.UnityEngine.Application.streamingAssetsPath.."/StreamingAssets"..v);
    end
end

--加载resources资源
function ResourcesManager:LoadResources(path)
    self.objMap[path] = CS.UnityEngine.Resources.Load(path);
    if self.objMap[path] then
        return true
    else
        return false
    end
end

--加载assetbundle资源
function ResourcesManager:LoadAssetBundle(type,path)
    --local load
    if type ==21 then
        return self:LoadLocalAssetBundle(path);
        --memoery load
    elseif type ==22 then
        return self:LoadMemoryAssetBundle(path);
        --request load
    elseif type ==23 then
        return self:LoadRequestAssetBundle();
    end

end

--加载本地assetbundle资源
--已测试
function ResourcesManager:LoadLocalAssetBundle(path)
    --加载
    local temp =CS.UnityEngine.AssetBundle.LoadFromFile(path);
    --缓存ab本身
    self.assetBundleCacheMap[path] ={assetBundle = temp,refCount =1};
    --寻找路径中的ab包名
    local tempPath = self:findName(path);
    --加载对象
    self.objMap[path]=temp:LoadAsset(tempPath);
    --print(self.objMap[path]);
    if self.objMap[path] then
        return true
    else
        return false
    end
end

--加载内存assetbundle资源
--
function ResourcesManager:LoadMemoryAssetBundle(path)
    --加载assetbundle
    local temp =CS.UnityEngine.AssetBundle.LoadFromMemory(CS.UnityEngine.Windows.File.ReadAllBytes(path));
    local tempPath = self:findName(path);
    --加载asset
    self.objMap[path]=temp:LoadAsset(tempPath);
    if self.objMap[path] then
        return true
    else
        return false
    end
end


--加载服务器assetbundle资源
--未实现
function ResourcesManager:LoadRequestAssetBundle()

end

--向对象池中存对象
function ResourcesManager:pushInPool(obj)
    table.insert(self.objPool,obj);
    obj:SetActive(false);
end

--从对象池中取对象
--存在index错误的可能，发生在对象池中不存在对象的情况下
function ResourcesManager:popPool()
    local obj =self.objPool[1];
    obj:SetActive(true);
    table.remove(self.objPool,1);
    return obj
end

ResourcesManager:init();

return ResourcesManager